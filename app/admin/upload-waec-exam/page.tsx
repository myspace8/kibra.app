// app/admin/upload-waec-exam/page.tsx
"use client"

import { useState } from "react"
import { supabase } from "@/lib/supabase"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { useSession } from "next-auth/react"
import { toast } from "@/components/ui/use-toast"
import { AlertCircle } from "lucide-react"

// Define interfaces
interface Question {
  question: string
  question_type: "objective" | "essay" | "comprehension_and_summary" | "guided_essay" | "theory" | "practical"
  topic: string
  subtopic?: string
  options?: string[]
  correct_answers?: string[]
  model_answer?: string
  explanation: string
  hint?: string
  difficulty: "Easy" | "Medium" | "Hard"
  marks: number
  media_url?: string
  media_type?: "image" | "audio" | "video"
  keywords?: string[]
  learning_objectives?: string[]
  estimated_time?: string
  source_reference?: string
  ai_feedback?: string
}

/**
 * Generate a JSON object for a WAEC exam that adheres to the following schema and requirements. The output must be valid JSON, properly formatted.

**Schema**:
- `exam_type`: String, either "BECE" or "WASSCE".
- `exam_year`: Integer, a future or current year (e.g., 2025).
- `exam_session`: String, either "May/June" or "November/December".
- `region`: String, a country or region (e.g., "Ghana", "Nigeria").
- `subject`: String, the subject name (e.g., "Mathematics", "Integrated Science"). Must be a valid subject that exists in a database.
- `syllabus_version`: String, format as "<year> Syllabus" (e.g., "2023 Syllabus").
- `questions`: Array of question objects, each with:
  - `question`: String, the question text (e.g., "What is 2 + 2?").
  - `question_type`: String, set to "objective".
  - `topic`: String, a specific topic within the subject (e.g., "Algebra" for Mathematics).
  - `subtopic`: String, a more specific subtopic.
  - `options`: Array of 4 strings, representing multiple-choice options.
  - `correct_answers`: Array of 1 string, the correct option from `options`.
  - `explanation`: String, a detailed explanation of why the correct answer is correct (1-2 sentences).
  - `hint`: String, a hint to help the test-taker.
  - `difficulty`: String, one of "Easy", "Medium", or "Hard".
  - `marks`: Integer, the marks for the question (e.g., 2).
  - `media_url`: String, URL to an image, audio, or video related to the question.
  - `media_type`: String, either "image", "audio", or "video".
  - `keywords`: Array of strings, keywords related to the question (e.g., ["Algebra", "Equations"]).
  - `learning_objectives`: Array of strings, learning objectives related to the question (e.g., ["Solve linear equations", "Understand algebraic expressions"]).
  - `estimated_time`: String, estimated time to answer the question (e.g., "2 minutes").
  - `source_reference`: String, a reference to the source of the question (e.g., "WAEC Past Questions").
  - `ai_feedback`: String, feedback generated by AI for the question (e.g., "This question tests basic arithmetic skills.").
- `questionCount`: Integer, the number of questions (matches length of `questions` array).
- `total_marks`: Integer, sum of `marks` from all questions.
- `duration`: String, duration of the exam (e.g., "30 minutes").
- `file_url`: String, URL to a file related to the exam.
- `isPublic`: Boolean, whether the exam is publicly accessible (true or false).
- `tags`: Array of strings, topics covered by the questions (e.g., ["Algebra", "Geometry"]).
- `difficulty`: String, overall exam difficulty ("Easy", "Medium", "Hard").
- `language`: String, set to "English".
- `status`: String, set to "Published".
- `instructions`: String, instructions for test-takers (e.g., "Select the correct answer for each question.").

**Requirements**:
- Generate an exam for the following parameters:
  - `exam_type`: "WASSCE"
  - `exam_year`: 2025
  - `exam_session`: "May/June"
  - `region`: "Ghana"
  - `subject`: "Mathematics"
  - `syllabus_version`: "2023 Syllabus"
  - `questions`: Array of question objects as described above.
  - `questionCount`: Number of questions in the exam.
  - `total_marks`: Total marks for the exam.
  - `duration`: Duration of the exam (e.g., "2 hours").
  - `file_url`: URL to a file related to the exam.
  - `isPublic`: Boolean indicating if the exam is public.
  - `tags`: Array of strings representing topics covered by the questions.
  - `difficulty`: Overall difficulty of the exam ("Easy", "Medium", "Hard").
  - `language`: Set to "English".
  - `status`: Set to "Published".
  - `instructions`: Instructions for test-takers (e.g., "Answer all questions.").

- Ensure questions are educationally accurate, relevant to [SUBJECT], and aligned with [EXAM_TYPE] (e.g., BECE for JHS, WASSCE for SHS).
- Distribute difficulty levels across questions (e.g., for 5 questions, include a mix like 2 Easy, 2 Medium, 1 Hard).
- Each question must have exactly 4 options and 1 correct answer.
- `tags` should reflect the topics of the questions.
- Ensure `total_marks` is the sum of marks for all questions.
- Ensure `questionCount` matches the number of questions in the `questions` array.
- Ensure `file_url` is a valid URL 
- Ensure `isPublic` is a boolean value. 
- Ensure `tags` is an array of strings.
- Ensure `difficulty` is one of "Easy", "Medium", or "Hard".
- Ensure `language` is a string.
- Ensure `status` is one of "Draft", "Published", or "Archived".
- Ensure `instructions` is a string.
- Ensure `exam_year` is a valid year (e.g., 2025).
- Ensure `exam_session` is either "May/June" or "November/December".
... etc.
- Ensure explanations are clear, concise, and educational.

**Output**:
Provide the JSON object, formatted with proper indentation, and nothing else. Do not include any additional text or comments.
 */

interface WAECExamData {
  exam_type: "BECE" | "WASSCE"
  exam_year: number
  exam_session: "May/June" | "November/December"
  region: string
  subject: string
  syllabus_version: string
  questions: Question[]
  questionCount: number
  total_marks: number
  duration: string
  file_url?: string
  isPublic: boolean
  tags: string[]
  difficulty: "Easy" | "Medium" | "Hard"
  language: string
  status: "Draft" | "Published" | "Archived"
  instructions?: string
}

export default function UploadWAECExam() {
  const { data: session, status } = useSession()
  const [jsonInput, setJsonInput] = useState("")
  const [error, setError] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)

  const validateWAECExamData = (data: any): data is WAECExamData => {
    if (!data || typeof data !== "object") {
      throw new Error("Input must be a valid JSON object")
    }

    const requiredFields = [
      "exam_type", "exam_year", "exam_session", "region", "subject",
      "syllabus_version", "questions", "questionCount", "total_marks", "duration",
      "isPublic", "tags", "difficulty", "language", "status"
    ]
    for (const field of requiredFields) {
      if (!(field in data)) {
        throw new Error(`Missing required field: ${field}`)
      }
    }

    if (!["BECE", "WASSCE"].includes(data.exam_type)) {
      throw new Error("exam_type must be 'BECE' or 'WASSCE'")
    }
    if (typeof data.exam_year !== "number" || data.exam_year < 2000 || data.exam_year > new Date().getFullYear() + 1) {
      throw new Error("exam_year must be a valid year")
    }
    if (!["May/June", "November/December"].includes(data.exam_session)) {
      throw new Error("exam_session must be 'May/June' or 'November/December'")
    }
    if (typeof data.region !== "string" || data.region.trim() === "") {
      throw new Error("region must be a non-empty string")
    }
    if (typeof data.subject !== "string" || data.subject.trim() === "") {
      throw new Error("subject must be a non-empty string")
    }
    if (typeof data.syllabus_version !== "string" || data.syllabus_version.trim() === "") {
      throw new Error("syllabus_version must be a non-empty string")
    }
    if (!Array.isArray(data.questions)) {
      throw new Error("questions must be an array")
    }
    if (typeof data.questionCount !== "number" || data.questionCount < 1) {
      throw new Error("questionCount must be a positive number")
    }
    if (typeof data.total_marks !== "number" || data.total_marks < 0) {
      throw new Error("total_marks must be a non-negative number")
    }
    if (typeof data.duration !== "string" || data.duration.trim() === "") {
      throw new Error("duration must be a non-empty string")
    }
    if (typeof data.isPublic !== "boolean") {
      throw new Error("isPublic must be a boolean")
    }
    if (!Array.isArray(data.tags)) {
      throw new Error("tags must be an array of strings")
    }
    if (!["Easy", "Medium", "Hard"].includes(data.difficulty)) {
      throw new Error("difficulty must be 'Easy', 'Medium', or 'Hard'")
    }
    if (typeof data.language !== "string" || data.language.trim() === "") {
      throw new Error("language must be a non-empty string")
    }
    if (!["Draft", "Published", "Archived"].includes(data.status)) {
      throw new Error("status must be 'Draft', 'Published', or 'Archived'")
    }

    if (data.questions.length !== data.questionCount) {
      throw new Error("questionCount must match the number of questions provided")
    }

    const totalMarks = data.questions.reduce((sum: number, q: any) => sum + (q.marks || 0), 0)
    if (totalMarks !== data.total_marks) {
      throw new Error("Total marks of questions must match the exam's total_marks")
    }

    data.questions.forEach((q: any, index: number) => {
      const requiredQuestionFields = ["question", "question_type", "topic", "explanation", "difficulty", "marks"]
      for (const field of requiredQuestionFields) {
        if (!(field in q)) {
          throw new Error(`Question at index ${index} is missing required field: ${field}`)
        }
      }
      if (typeof q.question !== "string" || q.question.trim() === "") {
        throw new Error(`Question at index ${index}: question must be a non-empty string`)
      }
      if (!["objective", "essay", "comprehension_and_summary", "guided_essay", "theory", "practical"].includes(q.question_type)) {
        throw new Error(`Question at index ${index}: question_type must be valid`)
      }
      if (typeof q.topic !== "string" || q.topic.trim() === "") {
        throw new Error(`Question at index ${index}: topic must be a non-empty string`)
      }
      if (typeof q.explanation !== "string" || q.explanation.trim() === "") {
        throw new Error(`Question at index ${index}: explanation must be a non-empty string`)
      }
      if (!["Easy", "Medium", "Hard"].includes(q.difficulty)) {
        throw new Error(`Question at index ${index}: difficulty must be 'Easy', 'Medium', or 'Hard'`)
      }
      if (typeof q.marks !== "number" || q.marks <= 0) {
        throw new Error(`Question at index ${index}: marks must be a positive number`)
      }

      if (q.question_type === "objective") {
        if (!Array.isArray(q.options) || q.options.length < 2) {
          throw new Error(`Question at index ${index}: objective questions must have at least 2 options`)
        }
        if (!Array.isArray(q.correct_answers) || q.correct_answers.length === 0) {
          throw new Error(`Question at index ${index}: objective questions must have at least 1 correct answer`)
        }
        q.correct_answers.forEach((ans: string) => {
          if (!q.options.includes(ans)) {
            throw new Error(`Question at index ${index}: correct_answer '${ans}' must be one of the provided options`)
          }
        })
      }

      if ((q.question_type === "essay" || q.question_type === "practical") && q.model_answer && typeof q.model_answer !== "string") {
        throw new Error(`Question at index ${index}: model_answer must be a string`)
      }
    })

    return true
  }

  const calculateSortDate = (examYear: number, examSession: string): string => {
    const month = examSession === "May/June" ? "06-01" : "11-01";
    return `${examYear}-${month}T00:00:00Z`;
  }

  const handleUpload = async () => {
    setLoading(true)
    setError(null)

    try {
      const parsedData = JSON.parse(jsonInput)

      if (!validateWAECExamData(parsedData)) {
        throw new Error("Invalid WAEC exam data format")
      }

      const { data: subjectData, error: subjectError } = await supabase
        .from("subjects")
        .select("id")
        .eq("name", parsedData.subject)
        .single()

      if (subjectError || !subjectData) {
        throw new Error(`Subject '${parsedData.subject}' not found in database`)
      }

      // Prepare waec_metadata
      const waecMetadata = {
        exam_type: parsedData.exam_type,
        exam_year: parsedData.exam_year,
        exam_session: parsedData.exam_session,
        region: parsedData.region,
        syllabus_version: parsedData.syllabus_version
      }

      /**
      * exam_type: "BECE" | "WASSCE"
        exam_year: number
        exam_session: "May/June" | "November/December"
        region: string
        subject: string
        syllabus_version: string
        questions: Question[]
        questionCount: number
        total_marks: number
        duration: string
        file_url?: string
        isPublic: boolean
        tags: string[]
        difficulty: "Easy" | "Medium" | "Hard"
        language: string
        status: "Draft" | "Published" | "Archived"
        instructions?: string
        
        
        subject: string
        questions: Question[]
        questionCount: number
        total_marks: number
        duration: string
        file_url?: string
        isPublic: boolean
        tags: string[]
        difficulty: "Easy" | "Medium" | "Hard"
        language: string
        status: "Draft" | "Published" | "Archived"
        instructions?: string
        */

      // Insert into exams table
      const { data: examData, error: examError } = await supabase
        .from("exams")
        .insert({
          exam_source: "waec",
          subject_id: subjectData.id,
          subject: parsedData.subject, // This is the subject name, not the ID. Create subject field in the exams table with the following SQL command:
          // ALTER TABLE exams ADD COLUMN subject VARCHAR(255); 
          question_count: parsedData.questionCount,
          total_marks: parsedData.total_marks,
          duration: parsedData.duration,
          is_public: parsedData.isPublic,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          sort_date: calculateSortDate(parsedData.exam_year, parsedData.exam_session), // Purpose: for sorting exams by date. This is used in the frontent to display the exams in a more user-friendly way. For example, if the exam is in May/June 2025, the sort_date will be "2025-06-01T00:00:00Z". This allows us to sort exams by their exam year and session.
          file_url: parsedData.file_url,
          instructions: parsedData.instructions,
          tags: parsedData.tags,
          difficulty: parsedData.difficulty,
          language: parsedData.language,
          status: parsedData.status,
          waec_exam_metadata: waecMetadata
        })
        .select("id")
        .single()

      if (examError || !examData) {
        throw new Error(`Failed to create exam: ${examError?.message || "Unknown error"}`)
      }

      const examId = examData.id
      

      // Insert questions into question_pool
      const questionInserts = parsedData.questions.map((q: Question) => ({
        question: q.question,
        question_type: q.question_type,
        topic: q.topic,
        subtopic: q.subtopic,
        options: q.options,
        correct_answers: q.correct_answers,
        model_answer: q.model_answer,
        explanation: q.explanation,
        hint: q.hint,
        difficulty: q.difficulty,
        marks: q.marks,
        media_url: q.media_url,
        media_type: q.media_type,
        keywords: q.keywords,
        learning_objectives: q.learning_objectives,
        estimated_time: q.estimated_time,
        source_reference: q.source_reference,
        ai_feedback: q.ai_feedback,
        created_by: session?.user?.id ?? null,
        source: "waec"
      }))

      const { data: questionData, error: questionError } = await supabase
        .from("question_pool")
        .insert(questionInserts)
        .select("id")

      if (questionError || !questionData) {
        throw new Error(`Failed to insert questions: ${questionError?.message || "Unknown error"}`)
      }

      // Link questions to exam via exam_questions
      const examQuestionInserts = questionData.map((q: any, index: number) => ({
        exam_id: examId,
        question_id: q.id,
        order: index + 1,
        marks: parsedData.questions[index].marks
      }))

      const { error: linkError } = await supabase
        .from("exam_questions")
        .insert(examQuestionInserts)

      if (linkError) {
        throw new Error(`Failed to link questions to exam: ${linkError.message}`)
      }

      toast({
        title: "Success",
        description: "WAEC exam uploaded successfully!"
      })
    } catch (err) {
      setError(err instanceof Error ? err.message : "Invalid JSON format")
    } finally {
      setLoading(false)
    }
  }

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-gray-600 dark:text-gray-400">Loading...</p>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-gray-800 p-4 sm:p-6">
      <div className="max-w-3xl mx-auto">
        <h1 className="text-3xl font-bold text-center mb-6 text-gray-800 dark:text-gray-100">
          Upload WAEC Exam
        </h1>
        <Card className="bg-white dark:bg-gray-800 shadow-lg">
          <CardHeader>
            <CardTitle className="text-xl text-gray-800 dark:text-gray-100">
              Import WAEC Exam as JSON
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Paste your WAEC exam data in JSON format. The format should match the example below.
            </p>
            <Textarea
              value={jsonInput}
              onChange={(e) => setJsonInput(e.target.value)}
              placeholder={`{
                "exam_type": "WASSCE",
                "exam_year": 2025,
                "exam_session": "May/June",
                "region": "Ghana",
                "subject": "Mathematics",
                "syllabus_version": "2023 Syllabus",
                "questions": [
                  {
                    "question": "Solve for x: 2x + 3 = 7",
                    "question_type": "objective",
                    "topic": "Algebra",
                    "options": ["2", "3", "4", "5"],
                    "correct_answers": ["2"],
                    "explanation": "Subtract 3 from both sides: 2x = 4, then divide by 2: x = 2.",
                    "difficulty": "Easy",
                    "marks": 5
                  }
                ],
                "questionCount": 1,
                "total_marks": 5,
                "duration": "2 hours",
                "isPublic": true,
                "tags": ["Algebra", "Equations"],
                "difficulty": "Medium",
                "language": "English",
                "status": "Published",
                "instructions": "Answer all questions."
              }`}
              className="min-h-[300px] font-mono text-sm border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-200"
            />
            {error && (
              <div className="flex items-start gap-2 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md text-red-800 dark:text-red-300">
                <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
                <div className="text-sm">{error}</div>
              </div>
            )}
          </CardContent>
        </Card>
        <div className="mt-6 flex justify-end gap-3">
          <Button
            variant="outline"
            onClick={() => window.history.back()}
            className="border-gray-300 dark:border-gray-600 dark:text-gray-200"
          >
            Cancel
          </Button>
          <Button
            onClick={handleUpload}
            disabled={loading}
            className="bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white"
          >
            {loading ? "Uploading..." : "Upload Exam"}
          </Button>
        </div>
      </div>
    </div>
  )
}